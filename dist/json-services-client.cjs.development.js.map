{"version":3,"file":"json-services-client.cjs.development.js","sources":["../src/Messages/AuthResponse.ts","../src/Messages/AuthRequest.ts","../src/EventFilter.ts","../src/Messages/SubscriptionMessage.ts","../src/ClientSubscription.ts","../src/ClientSubscriptionManager.ts","../src/CredentialsBase.ts","../.yarn/cache/babel-plugin-transform-async-to-promises-npm-0.8.15-e24f37569f-1.zip/node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Messages/LogoutMessage.ts","../src/PendingMessage.ts","../src/RequestMessage.ts","../src/JsonClient.ts","../src/Messages/VersionResponse.ts","../src/Messages/VersionRequest.ts"],"sourcesContent":["export class AuthResponse {\r\n    public Parameters!: {\r\n        [key: string]: string\r\n    }\r\n\r\n    public SessionId!: string\r\n\r\n    public AuthenticatedIdentity!: {\r\n        Name: string\r\n        AuthenticationType: string\r\n        IsAuthenticated: boolean\r\n    }\r\n}","import { AuthResponse } from \"./AuthResponse\"\r\nimport { IReturn } from \"../IReturn\"\r\n\r\nexport class AuthRequest implements IReturn<AuthResponse> {\r\n    public static userNameKey = \"UserName\"\r\n    public static passwordKey = \"Password\"\r\n    public getTypeName = () => \"rpc.authenticate\"\r\n    public createResponse = () => new AuthResponse()\r\n    public Parameters: {\r\n        [key: string]: string\r\n    } = {}\r\n}\r\n","export interface IEventFilter {\r\n    [key: string]: string | null\r\n}\r\n\r\nexport class EventFilter {\r\n    public static matches(eventFilter?: IEventFilter | null, eventArgs?: { [key: string]: any } | null): boolean {\r\n        // empty filter matches anything\r\n        if (eventFilter === null ||\r\n            eventFilter === undefined ||\r\n            Object.keys(eventFilter).length === 0) {\r\n            return true\r\n        }\r\n\r\n        // empty event arguments doesn't match any filter except for empty filter\r\n        if (eventArgs === null || eventArgs === undefined) {\r\n            return false\r\n        }\r\n\r\n        // match individual properties based on their types\r\n        for (const key in eventFilter) {\r\n            // check eventFilter's own properties\r\n            if (Object.prototype.hasOwnProperty.call(eventFilter, key)) {\r\n                const filterValue = eventFilter[key] || \"\"\r\n                const propertyValue = eventArgs[key]\r\n                if (!this.valueMatches(filterValue, propertyValue)) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    public static valueMatches(filterValue: string, propertyValue: any) {\r\n        // property not found\r\n        if (propertyValue === undefined) {\r\n            return false\r\n        }\r\n\r\n        // empty filter matches anything\r\n        if ((filterValue || \"\") === \"\") {\r\n            return true\r\n        }\r\n\r\n        // match based on the property value type\r\n        if (filterValue === (propertyValue || \"\").toString()) {\r\n            return true\r\n        } else if (typeof propertyValue === \"string\") {\r\n            return this.stringMatches(filterValue, propertyValue)\r\n        } else if (typeof propertyValue === \"number\") {\r\n            return this.numberMatches(filterValue, propertyValue)\r\n        } else if (typeof propertyValue === \"boolean\") {\r\n            return this.boolMatches(filterValue, propertyValue)\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    public static stringMatches(filterValue?: string | null, propertyValue?: string | null) {\r\n        // avoid null and undefined\r\n        filterValue = (filterValue || \"\").toLowerCase()\r\n        propertyValue = (propertyValue || \"\").toLowerCase()\r\n        return propertyValue.indexOf(filterValue) >= 0\r\n    }\r\n\r\n    public static numberMatches(filterValue?: string | null, propertyValue?: number | null) {\r\n        // avoid null and undefined\r\n        filterValue = filterValue || \"\"\r\n        if (filterValue === \"\") {\r\n            return true\r\n        }\r\n\r\n        const value = propertyValue || \"\"\r\n        const parts = filterValue.toLowerCase().split(\",\")\r\n        return parts.findIndex(v => v === value.toString()) >= 0\r\n    }\r\n\r\n    public static boolMatches(filterValue?: string | null, propertyValue?: boolean | null) {\r\n        // avoid null and undefined\r\n        filterValue = filterValue || \"\"\r\n        if (filterValue === \"\") {\r\n            return true\r\n        }\r\n\r\n        const value = (propertyValue || false).toString().toLowerCase().trim()\r\n        return filterValue.toLowerCase().trim() === value\r\n    }\r\n}","import { IReturnVoid } from \"../IReturn\"\r\n\r\ninterface ISubscription {\r\n    SubscriptionId: string\r\n    Enabled: boolean\r\n    EventName: string\r\n    EventFilter?: {\r\n        [key: string]: string\r\n    }\r\n}\r\n\r\nexport class SubscriptionMessage implements IReturnVoid {\r\n    public static messageName = \"rpc.subscription\"\r\n    public getTypeName = () => SubscriptionMessage.messageName\r\n    public Subscriptions!: ISubscription[]\r\n}\r\n","import { EventFilter } from \"./EventFilter\"\r\nimport { SubscriptionMessage } from \"./Messages/SubscriptionMessage\"\r\n\r\nexport class ClientSubscription {\r\n    public subscriptionId!: string\r\n    public eventName!: string\r\n    public eventHandler!: (eventArgs: object) => void\r\n    public eventFilter?: {\r\n        [key: string]: string;\r\n    }\r\n\r\n    public invoke = (eventArgs: object) => {\r\n        // TODO: handle 'this' context?\r\n        // apply eventFilter locally (we might get events matching other local subscriber's event filter)\r\n        if (EventFilter.matches(this.eventFilter, eventArgs)) {\r\n            this.eventHandler(eventArgs)\r\n        }\r\n    }\r\n\r\n    public createSubscriptionMessage = () => {\r\n        const msg = new SubscriptionMessage()\r\n        msg.Subscriptions = [{\r\n            Enabled: true,\r\n            EventName: this.eventName,\r\n            EventFilter: this.eventFilter,\r\n            SubscriptionId: this.subscriptionId,\r\n        }]\r\n        return msg\r\n    }\r\n\r\n    public createUnsubscriptionMessage = () => {\r\n        const msg = this.createSubscriptionMessage()\r\n        delete msg.Subscriptions[0].EventFilter\r\n        msg.Subscriptions[0].Enabled = false\r\n        return msg\r\n    }\r\n}","import { EventEmitter } from \"eventemitter3\"\r\nimport { ClientSubscription } from \"./ClientSubscription\"\r\n\r\nexport class ClientSubscriptionManager {\r\n    private emitter = new EventEmitter()\r\n    private subscriptions: { [subscriptionId: string]: ClientSubscription; } = {}\r\n\r\n    public add = (subscription: ClientSubscription) => {\r\n        this.subscriptions[subscription.subscriptionId] = subscription\r\n        this.emitter.on(subscription.eventName, subscription.invoke, subscription)\r\n\r\n        return () => {\r\n            delete this.subscriptions[subscription.subscriptionId]\r\n            this.emitter.off(subscription.eventName, subscription.invoke, subscription)\r\n        }\r\n    }\r\n\r\n    public broadcast = (eventName: string, eventArgs: object) => {\r\n        this.emitter.emit(eventName, eventArgs)\r\n    }\r\n}","import { AuthRequest } from \"./Messages/AuthRequest\"\r\nimport { ICredentials } from \"./ICredentials\"\r\nimport { IJsonClient } from \"./IJsonClient\"\r\n\r\nexport class CredentialsBase implements ICredentials {\r\n    constructor(credentials?: {\r\n        userName: string,\r\n        password: string,\r\n    } | undefined) {\r\n        // initialize parameters if specified\r\n        if (credentials) {\r\n            this.parameters[AuthRequest.userNameKey] = credentials.userName\r\n            this.parameters[AuthRequest.passwordKey] = credentials.password\r\n        }\r\n    }\r\n\r\n    public async authenticate(client: IJsonClient): Promise<string> {\r\n        const msg = new AuthRequest()\r\n        msg.Parameters = this.parameters\r\n        const response = await client.call(msg)\r\n        return response.SessionId\r\n    }\r\n\r\n    public parameters: {\r\n        [key: string]: string\r\n    } = {}\r\n}","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { IReturnVoid } from \"../IReturn\"\r\n\r\nexport class LogoutMessage implements IReturnVoid {\r\n    public getTypeName() {\r\n        return \"rpc.logout\"\r\n    }\r\n}","﻿export class PendingMessage {\r\n    constructor(public id: string, public promise?: Promise<any>) {\r\n    }\r\n\r\n    public resolve!: (result: any) => void\r\n    public reject!: (error: any) => void\r\n}\r\n\r\nexport interface IPendingMessageQueue {\r\n    [key: string]: PendingMessage | undefined\r\n}","﻿export class RequestMessage {\r\n    constructor(method: string, params: object, id?: string) {\r\n        this.method = method\r\n        this.params = params\r\n        this.id = id\r\n    }\r\n\r\n    public jsonrpc = \"2.0\"\r\n    public method: string\r\n    public params: object\r\n    public id?: string\r\n}","﻿import WebSocket from \"isomorphic-ws\"\r\nimport { ClientSubscription } from \"./ClientSubscription\"\r\nimport { ClientSubscriptionManager } from \"./ClientSubscriptionManager\"\r\nimport { CredentialsBase } from \"./CredentialsBase\"\r\nimport { ICredentials } from \"./ICredentials\"\r\nimport { IJsonClient } from \"./IJsonClient\"\r\nimport { IReturn, IReturnVoid } from \"./IReturn\"\r\nimport { ISubscription } from \"./ISubscription\"\r\nimport { LogoutMessage } from \"./Messages/LogoutMessage\"\r\nimport { IPendingMessageQueue, PendingMessage } from \"./PendingMessage\"\r\nimport { RequestMessage } from \"./RequestMessage\"\r\n\r\nexport interface IJsonRpcError {\r\n    code: number\r\n    message: string\r\n    data: object\r\n}\r\n\r\nexport interface IJsonClientOptions {\r\n    reconnect: boolean\r\n    reconnectInterval: number\r\n    maxReconnects: number\r\n    credentials?: ICredentials\r\n}\r\n\r\nexport class JsonClient implements IJsonClient {\r\n    constructor(public url: string, private options: IJsonClientOptions = {\r\n        reconnect: true,\r\n        reconnectInterval: 5000,\r\n        maxReconnects: 10,\r\n    }) {\r\n        this.credentials = options.credentials\r\n\r\n        // make sure that this argument stays\r\n        this.call = this.call.bind(this)\r\n        this.notify = this.notify.bind(this)\r\n        this.subscribe = this.subscribe.bind(this)\r\n        this.generateMessageId = this.generateMessageId.bind(this)\r\n        this.nameOf = this.nameOf.bind(this)\r\n    }\r\n\r\n    public connected = false\r\n    public sessionId?: string\r\n    public credentials?: ICredentials\r\n    private webSocket?: WebSocket\r\n    private reconnects = 0\r\n    private pendingMessages: IPendingMessageQueue = {}\r\n\r\n    public traceMessage = (_: { isOutcoming: boolean, data: string }) => {\r\n        // do nothing by default\r\n    }\r\n\r\n    public errorFilter = (_: Error | IJsonRpcError) => {\r\n        // do nothing by default\r\n    }\r\n\r\n    public async disconnect() {\r\n        if (this.webSocket && this.connected) {\r\n            await this.notify(new LogoutMessage())\r\n            this.webSocket.close()\r\n            this.connected = false\r\n            delete this.webSocket\r\n            delete this.connectPromise\r\n        }\r\n    }\r\n\r\n    private rejectPendingMessages(closeEvent: {\r\n        wasClean: boolean;\r\n        code: number;\r\n        reason: string;\r\n        target: WebSocket;\r\n    }) {\r\n        let message = \"Connection was closed.\"\r\n        if (closeEvent.code !== 1000) {\r\n            message = \"Connection was aborted. Error code: \" + closeEvent.code\r\n        }\r\n\r\n        const error = new Error(message)\r\n        Object.defineProperty(error, \"code\", { value: -32003 })\r\n\r\n        for (const messageId in this.pendingMessages) {\r\n            if (Object.prototype.hasOwnProperty.call(this.pendingMessages, messageId)) {\r\n                const pending = this.pendingMessages[messageId]\r\n                if (pending) {\r\n                    // clear pending message\r\n                    delete this.pendingMessages[messageId]\r\n\r\n                    // reject the promise\r\n                    this.errorFilter(error)\r\n                    pending.reject(error)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private connectPromise?: Promise<string>\r\n\r\n    public connect(credentials?: ICredentials): Promise<string> {\r\n        // you only connect once\r\n        if (this.connectPromise) {\r\n            return this.connectPromise\r\n        }\r\n\r\n        // make sure to have some credentials\r\n        const creds: ICredentials = credentials || this.credentials || new CredentialsBase()\r\n\r\n        return this.connectPromise = new Promise<string>((resolve, reject) => {\r\n            // check if already connected\r\n            if (this.webSocket) {\r\n                resolve(this.sessionId)\r\n                return\r\n            }\r\n\r\n            this.webSocket = new WebSocket(this.url)\r\n\r\n            this.webSocket.onerror = (error: any) => {\r\n                this.connected = false\r\n                delete this.webSocket\r\n                delete this.connectPromise\r\n\r\n                let message = \"Couldn't connect to \" + this.url\r\n                if (error.message) {\r\n                    message = message + \": \" + error.message\r\n                }\r\n\r\n                const e = new Error(message)\r\n                this.errorFilter(e)\r\n                reject(e)\r\n            }\r\n\r\n            this.webSocket.onopen = async () => {\r\n                // this is crucial for the subsequent authenticate call\r\n                this.connected = true\r\n                try {\r\n                    // authenticate\r\n                    this.sessionId = await creds.authenticate(this)\r\n\r\n                    // great, now we're connected\r\n                    this.reconnects = 0\r\n                    resolve(this.sessionId)\r\n                } catch (e) {\r\n                    // report failure\r\n                    this.connected = false\r\n                    this.errorFilter(e)\r\n                    reject(e)\r\n                    delete this.webSocket\r\n                    delete this.connectPromise\r\n                }\r\n            }\r\n\r\n            this.webSocket.onclose = (closeEvent: any) => {\r\n                this.connected = false\r\n                this.rejectPendingMessages(closeEvent)\r\n                delete this.webSocket\r\n                delete this.connectPromise\r\n\r\n                if (closeEvent.code === 1000) {\r\n                    resolve(this.sessionId)\r\n                    return // closed normally, don't reconnect\r\n                }\r\n\r\n                this.reconnects++\r\n                if (this.options.reconnect && (this.options.maxReconnects < this.reconnects || this.options.maxReconnects === 0)) {\r\n                    setTimeout(() => this.connect(), this.options.reconnectInterval)\r\n                }\r\n\r\n                resolve(this.sessionId)\r\n            }\r\n\r\n            this.webSocket.onmessage = (message: any) => {\r\n                // trace incoming message\r\n                this.traceMessage({\r\n                    isOutcoming: false,\r\n                    data: message.data.toString(),\r\n                })\r\n\r\n                // if message is binary data, convert it to string\r\n                let json = typeof(message.data) === \"string\" ? message.data : \"\"\r\n                if (message.data instanceof ArrayBuffer) {\r\n                    json = Buffer.from(message.data).toString()\r\n                }\r\n\r\n                // parse message and get its data\r\n                let parsedMessage: {\r\n                    id?: string,\r\n                    method?: string,\r\n                    params?: object,\r\n                    result?: object,\r\n                    error?: IJsonRpcError,\r\n                }\r\n\r\n                try {\r\n                    parsedMessage = JSON.parse(json)\r\n                } catch(e) {\r\n                    // TODO: decide how to handle parse errors\r\n                    this.errorFilter(e)\r\n                    this.errorFilter(new Error(\"Error parsing JSON: \" + json))\r\n                    return\r\n                }\r\n\r\n                // check if it's a reply\r\n                if (parsedMessage.id) {\r\n                    const pending = this.pendingMessages[parsedMessage.id]\r\n                    if (pending) {\r\n                        // clear pending message\r\n                        delete this.pendingMessages[parsedMessage.id]\r\n\r\n                        // resolve or reject the promise depending on the parsed message data\r\n                        if (parsedMessage.error) {\r\n                            this.errorFilter(parsedMessage.error)\r\n                            pending.reject(parsedMessage.error)\r\n                            return\r\n                        } else {\r\n                            pending.resolve(parsedMessage.result)\r\n                        }\r\n                    }\r\n\r\n                    // TODO: decide how to handle unknown responses from server\r\n                    return\r\n                }\r\n\r\n                // it's a notification, fire an event\r\n                this.subscriptionManager.broadcast(parsedMessage.method!, parsedMessage.params!)\r\n            }\r\n        })\r\n    }\r\n\r\n    public call<T>(message: IReturn<T>): Promise<T>\r\n    public call(message: IReturnVoid): Promise<any>\r\n    public async call<T>(message: IReturn<T> | IReturnVoid): Promise<any> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        return await this.callCore(message)\r\n    }\r\n\r\n    private callCore<T>(message: IReturn<T> | IReturnVoid): Promise<any> {\r\n        const name = this.nameOf(message)\r\n        const messageId = this.generateMessageId()\r\n        const msg = new RequestMessage(name, message, messageId)\r\n        const serialized = JSON.stringify(msg)\r\n\r\n        // prepare pending message\r\n        const pendingMessage = new PendingMessage(messageId)\r\n        this.pendingMessages[messageId] = pendingMessage\r\n\r\n        // return a promise awaiting the results of the call\r\n        return pendingMessage.promise = new Promise((resolve, reject) => {\r\n            // store resolve/reject callbacks for later use\r\n            pendingMessage.resolve = resolve\r\n            pendingMessage.reject = reject\r\n\r\n            // fail early if not connected\r\n            if (this.webSocket === undefined || !this.connected) {\r\n                delete this.pendingMessages[messageId]\r\n                const e = new Error(\"WebSocket not connected\")\r\n                this.errorFilter(e)\r\n                reject(e)\r\n                return\r\n            }\r\n\r\n            // trace outcoming message\r\n            this.traceMessage({\r\n                isOutcoming: true,\r\n                data: serialized\r\n            })\r\n\r\n            // send it\r\n            this.webSocket.send(serialized)\r\n        })\r\n    }\r\n\r\n    // one-way calls\r\n    public async notify<T>(message: IReturn<T> | IReturnVoid): Promise<void> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        const name = this.nameOf(message)\r\n        const msg = new RequestMessage(name, message)\r\n        const serialized = JSON.stringify(msg)\r\n\r\n        // fail if not connected\r\n        if (this.webSocket === undefined || !this.connected) {\r\n            const e = new Error(\"WebSocket not connected\")\r\n            this.errorFilter(e)\r\n            throw e\r\n        }\r\n\r\n        // trace outcoming message\r\n        this.traceMessage({\r\n            isOutcoming: true,\r\n            data: serialized\r\n        })\r\n\r\n        // send it\r\n        this.webSocket.send(serialized)\r\n    }\r\n\r\n    // outgoing message ids\r\n    private lastMessageId = 0\r\n    private generateMessageId() {\r\n        return ++this.lastMessageId + \"\"\r\n    }\r\n\r\n    // stolen from the ServiceStack client\r\n    public nameOf(o: any) {\r\n        if (!o) {\r\n            return \"null\"\r\n        }\r\n\r\n        if (typeof o.getTypeName === \"function\") {\r\n            return o.getTypeName()\r\n        }\r\n\r\n        const ctor = o && o.constructor\r\n        if (ctor === null) {\r\n            const e = new Error(`${o} doesn't have constructor`)\r\n            this.errorFilter(e)\r\n            throw e\r\n        }\r\n\r\n        if (ctor.name) {\r\n            return ctor.name\r\n        }\r\n\r\n        const str = ctor.toString()\r\n        return str.substring(9, str.indexOf(\"(\")) // \"function \".length == 9\r\n    }\r\n\r\n    private subscriptionManager = new ClientSubscriptionManager()\r\n\r\n    // returns unsubscription function\r\n    public async subscribe(event: ISubscription): Promise<() => Promise<void>> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        const cs = new ClientSubscription()\r\n        cs.subscriptionId = this.generateMessageId()\r\n        cs.eventName = event.eventName\r\n        cs.eventHandler = event.eventHandler\r\n        cs.eventFilter = event.eventFilter\r\n\r\n        // notify the server about the new subscription\r\n        const subMessage = cs.createSubscriptionMessage()\r\n        await this.call(subMessage)\r\n\r\n        // return async unsubscription\r\n        const unsubscribe = this.subscriptionManager.add(cs)\r\n        const unsubMessage = cs.createUnsubscriptionMessage()\r\n        return async () => {\r\n            unsubscribe()\r\n            await this.call(unsubMessage)\r\n        }\r\n    }\r\n}\r\n\r\nexport default JsonClient\r\n","export class VersionResponse {\r\n    public ProductName!: string\r\n    public ProductVersion!: string\r\n    public EngineVersion!: string\r\n}\r\n","import { IReturn } from \"../IReturn\"\r\nimport { VersionResponse } from \"./VersionResponse\"\r\n\r\nexport class VersionRequest implements IReturn<VersionResponse> {\r\n    public getTypeName() {\r\n        return \"rpc.version\"\r\n    }\r\n    public createResponse(): VersionResponse {\r\n        return new VersionResponse()\r\n    }\r\n}"],"names":["AuthResponse","AuthRequest","EventFilter","matches","eventFilter","eventArgs","undefined","Object","keys","length","key","prototype","hasOwnProperty","call","filterValue","propertyValue","valueMatches","toString","stringMatches","numberMatches","boolMatches","toLowerCase","indexOf","value","parts","split","findIndex","v","trim","SubscriptionMessage","messageName","ClientSubscription","eventHandler","msg","Subscriptions","Enabled","EventName","eventName","SubscriptionId","subscriptionId","createSubscriptionMessage","ClientSubscriptionManager","EventEmitter","subscription","subscriptions","emitter","on","invoke","off","emit","CredentialsBase","credentials","parameters","userNameKey","userName","passwordKey","password","authenticate","client","Parameters","response","SessionId","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_catch","body","recover","result","e","then","LogoutMessage","getTypeName","PendingMessage","id","promise","RequestMessage","method","params","JsonClient","url","options","reconnect","reconnectInterval","maxReconnects","_","bind","notify","subscribe","generateMessageId","nameOf","disconnect","webSocket","connected","close","connectPromise","rejectPendingMessages","closeEvent","message","code","error","Error","defineProperty","messageId","pendingMessages","pending","errorFilter","reject","connect","creds","Promise","resolve","sessionId","WebSocket","onerror","onopen","reconnects","onclose","setTimeout","onmessage","traceMessage","isOutcoming","data","json","ArrayBuffer","Buffer","from","parsedMessage","JSON","parse","subscriptionManager","broadcast","callCore","name","serialized","stringify","pendingMessage","send","lastMessageId","o","ctor","constructor","str","substring","event","cs","subMessage","unsubscribe","add","unsubMessage","createUnsubscriptionMessage","VersionResponse","VersionRequest","createResponse"],"mappings":"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"}