{"version":3,"file":"json-services-client.cjs.production.min.js","sources":["../src/Messages/AuthResponse.ts","../src/Messages/AuthRequest.ts","../src/EventFilter.ts","../src/Messages/SubscriptionMessage.ts","../src/ClientSubscription.ts","../src/ClientSubscriptionManager.ts","../src/CredentialsBase.ts","../src/Messages/LogoutMessage.ts","../src/PendingMessage.ts","../src/RequestMessage.ts","../src/JsonClient.ts","../src/Messages/VersionResponse.ts","../src/Messages/VersionRequest.ts"],"sourcesContent":["export class AuthResponse {\r\n    public Parameters!: {\r\n        [key: string]: string\r\n    }\r\n\r\n    public SessionId!: string\r\n\r\n    public AuthenticatedIdentity!: {\r\n        Name: string\r\n        AuthenticationType: string\r\n        IsAuthenticated: boolean\r\n    }\r\n}","import { AuthResponse } from \"./AuthResponse\"\r\nimport { IReturn } from \"../IReturn\"\r\n\r\nexport class AuthRequest implements IReturn<AuthResponse> {\r\n    public static userNameKey = \"UserName\"\r\n    public static passwordKey = \"Password\"\r\n    public getTypeName = () => \"rpc.authenticate\"\r\n    public createResponse = () => new AuthResponse()\r\n    public Parameters: {\r\n        [key: string]: string\r\n    } = {}\r\n}\r\n","export interface IEventFilter {\r\n    [key: string]: string | null\r\n}\r\n\r\nexport class EventFilter {\r\n    public static matches(eventFilter?: IEventFilter | null, eventArgs?: { [key: string]: any } | null): boolean {\r\n        // empty filter matches anything\r\n        if (eventFilter === null ||\r\n            eventFilter === undefined ||\r\n            Object.keys(eventFilter).length === 0) {\r\n            return true\r\n        }\r\n\r\n        // empty event arguments doesn't match any filter except for empty filter\r\n        if (eventArgs === null || eventArgs === undefined) {\r\n            return false\r\n        }\r\n\r\n        // match individual properties based on their types\r\n        for (const key in eventFilter) {\r\n            // check eventFilter's own properties\r\n            if (Object.prototype.hasOwnProperty.call(eventFilter, key)) {\r\n                const filterValue = eventFilter[key] || \"\"\r\n                const propertyValue = eventArgs[key]\r\n                if (!this.valueMatches(filterValue, propertyValue)) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    public static valueMatches(filterValue: string, propertyValue: any) {\r\n        // property not found\r\n        if (propertyValue === undefined) {\r\n            return false\r\n        }\r\n\r\n        // empty filter matches anything\r\n        if ((filterValue || \"\") === \"\") {\r\n            return true\r\n        }\r\n\r\n        // match based on the property value type\r\n        if (filterValue === (propertyValue || \"\").toString()) {\r\n            return true\r\n        } else if (typeof propertyValue === \"string\") {\r\n            return this.stringMatches(filterValue, propertyValue)\r\n        } else if (typeof propertyValue === \"number\") {\r\n            return this.numberMatches(filterValue, propertyValue)\r\n        } else if (typeof propertyValue === \"boolean\") {\r\n            return this.boolMatches(filterValue, propertyValue)\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    public static stringMatches(filterValue?: string | null, propertyValue?: string | null) {\r\n        // avoid null and undefined\r\n        filterValue = (filterValue || \"\").toLowerCase()\r\n        propertyValue = (propertyValue || \"\").toLowerCase()\r\n        return propertyValue.indexOf(filterValue) >= 0\r\n    }\r\n\r\n    public static numberMatches(filterValue?: string | null, propertyValue?: number | null) {\r\n        // avoid null and undefined\r\n        filterValue = filterValue || \"\"\r\n        if (filterValue === \"\") {\r\n            return true\r\n        }\r\n\r\n        const value = propertyValue || \"\"\r\n        const parts = filterValue.toLowerCase().split(\",\")\r\n        return parts.findIndex(v => v === value.toString()) >= 0\r\n    }\r\n\r\n    public static boolMatches(filterValue?: string | null, propertyValue?: boolean | null) {\r\n        // avoid null and undefined\r\n        filterValue = filterValue || \"\"\r\n        if (filterValue === \"\") {\r\n            return true\r\n        }\r\n\r\n        const value = (propertyValue || false).toString().toLowerCase().trim()\r\n        return filterValue.toLowerCase().trim() === value\r\n    }\r\n}","import { IReturnVoid } from \"../IReturn\"\r\n\r\ninterface ISubscription {\r\n    SubscriptionId: string\r\n    Enabled: boolean\r\n    EventName: string\r\n    EventFilter?: {\r\n        [key: string]: string\r\n    }\r\n}\r\n\r\nexport class SubscriptionMessage implements IReturnVoid {\r\n    public static messageName = \"rpc.subscription\"\r\n    public getTypeName = () => SubscriptionMessage.messageName\r\n    public Subscriptions!: ISubscription[]\r\n}\r\n","import { EventFilter } from \"./EventFilter\"\r\nimport { SubscriptionMessage } from \"./Messages/SubscriptionMessage\"\r\n\r\nexport class ClientSubscription {\r\n    public subscriptionId!: string\r\n    public eventName!: string\r\n    public eventHandler!: (eventArgs: object) => void\r\n    public eventFilter?: {\r\n        [key: string]: string;\r\n    }\r\n\r\n    public invoke = (eventArgs: object) => {\r\n        // TODO: handle 'this' context?\r\n        // apply eventFilter locally (we might get events matching other local subscriber's event filter)\r\n        if (EventFilter.matches(this.eventFilter, eventArgs)) {\r\n            this.eventHandler(eventArgs)\r\n        }\r\n    }\r\n\r\n    public createSubscriptionMessage = () => {\r\n        const msg = new SubscriptionMessage()\r\n        msg.Subscriptions = [{\r\n            Enabled: true,\r\n            EventName: this.eventName,\r\n            EventFilter: this.eventFilter,\r\n            SubscriptionId: this.subscriptionId,\r\n        }]\r\n        return msg\r\n    }\r\n\r\n    public createUnsubscriptionMessage = () => {\r\n        const msg = this.createSubscriptionMessage()\r\n        delete msg.Subscriptions[0].EventFilter\r\n        msg.Subscriptions[0].Enabled = false\r\n        return msg\r\n    }\r\n}","import { EventEmitter } from \"eventemitter3\"\r\nimport { ClientSubscription } from \"./ClientSubscription\"\r\n\r\nexport class ClientSubscriptionManager {\r\n    private emitter = new EventEmitter()\r\n    private subscriptions: { [subscriptionId: string]: ClientSubscription; } = {}\r\n\r\n    public add = (subscription: ClientSubscription) => {\r\n        this.subscriptions[subscription.subscriptionId] = subscription\r\n        this.emitter.on(subscription.eventName, subscription.invoke, subscription)\r\n\r\n        return () => {\r\n            delete this.subscriptions[subscription.subscriptionId]\r\n            this.emitter.off(subscription.eventName, subscription.invoke, subscription)\r\n        }\r\n    }\r\n\r\n    public broadcast = (eventName: string, eventArgs: object) => {\r\n        this.emitter.emit(eventName, eventArgs)\r\n    }\r\n}","import { AuthRequest } from \"./Messages/AuthRequest\"\r\nimport { ICredentials } from \"./ICredentials\"\r\nimport { IJsonClient } from \"./IJsonClient\"\r\n\r\nexport class CredentialsBase implements ICredentials {\r\n    constructor(credentials?: {\r\n        userName: string,\r\n        password: string,\r\n    } | undefined) {\r\n        // initialize parameters if specified\r\n        if (credentials) {\r\n            this.parameters[AuthRequest.userNameKey] = credentials.userName\r\n            this.parameters[AuthRequest.passwordKey] = credentials.password\r\n        }\r\n    }\r\n\r\n    public async authenticate(client: IJsonClient): Promise<string> {\r\n        const msg = new AuthRequest()\r\n        msg.Parameters = this.parameters\r\n        const response = await client.call(msg)\r\n        return response.SessionId\r\n    }\r\n\r\n    public parameters: {\r\n        [key: string]: string\r\n    } = {}\r\n}","import { IReturnVoid } from \"../IReturn\"\r\n\r\nexport class LogoutMessage implements IReturnVoid {\r\n    public getTypeName() {\r\n        return \"rpc.logout\"\r\n    }\r\n}","﻿export class PendingMessage {\r\n    constructor(public id: string, public promise?: Promise<any>) {\r\n    }\r\n\r\n    public resolve!: (result: any) => void\r\n    public reject!: (error: any) => void\r\n}\r\n\r\nexport interface IPendingMessageQueue {\r\n    [key: string]: PendingMessage | undefined\r\n}","﻿export class RequestMessage {\r\n    constructor(method: string, params: object, id?: string) {\r\n        this.method = method\r\n        this.params = params\r\n        this.id = id\r\n    }\r\n\r\n    public jsonrpc = \"2.0\"\r\n    public method: string\r\n    public params: object\r\n    public id?: string\r\n}","﻿import WebSocket from \"isomorphic-ws\"\r\nimport { ClientSubscription } from \"./ClientSubscription\"\r\nimport { ClientSubscriptionManager } from \"./ClientSubscriptionManager\"\r\nimport { CredentialsBase } from \"./CredentialsBase\"\r\nimport { ICredentials } from \"./ICredentials\"\r\nimport { IJsonClient } from \"./IJsonClient\"\r\nimport { IReturn, IReturnVoid } from \"./IReturn\"\r\nimport { ISubscription } from \"./ISubscription\"\r\nimport { LogoutMessage } from \"./Messages/LogoutMessage\"\r\nimport { IPendingMessageQueue, PendingMessage } from \"./PendingMessage\"\r\nimport { RequestMessage } from \"./RequestMessage\"\r\n\r\nexport interface IJsonRpcError {\r\n    code: number\r\n    message: string\r\n    data: object\r\n}\r\n\r\nexport interface IJsonClientOptions {\r\n    reconnect: boolean\r\n    reconnectInterval: number\r\n    maxReconnects: number\r\n    credentials?: ICredentials\r\n}\r\n\r\nexport class JsonClient implements IJsonClient {\r\n    constructor(public url: string, private options: IJsonClientOptions = {\r\n        reconnect: true,\r\n        reconnectInterval: 5000,\r\n        maxReconnects: 10,\r\n    }) {\r\n        this.credentials = options.credentials\r\n\r\n        // make sure that this argument stays\r\n        this.call = this.call.bind(this)\r\n        this.notify = this.notify.bind(this)\r\n        this.subscribe = this.subscribe.bind(this)\r\n        this.generateMessageId = this.generateMessageId.bind(this)\r\n        this.nameOf = this.nameOf.bind(this)\r\n    }\r\n\r\n    public connected = false\r\n    public sessionId?: string\r\n    public credentials?: ICredentials\r\n    private webSocket?: WebSocket\r\n    private reconnects = 0\r\n    private pendingMessages: IPendingMessageQueue = {}\r\n\r\n    public traceMessage = (_: { isOutcoming: boolean, data: string }) => {\r\n        // do nothing by default\r\n    }\r\n\r\n    public errorFilter = (_: Error | IJsonRpcError) => {\r\n        // do nothing by default\r\n    }\r\n\r\n    public async disconnect() {\r\n        if (this.webSocket && this.connected) {\r\n            await this.notify(new LogoutMessage())\r\n            this.webSocket.close()\r\n            this.connected = false\r\n            delete this.webSocket\r\n            delete this.connectPromise\r\n        }\r\n    }\r\n\r\n    private rejectPendingMessages(closeEvent: {\r\n        wasClean: boolean;\r\n        code: number;\r\n        reason: string;\r\n        target: WebSocket;\r\n    }) {\r\n        let message = \"Connection was closed.\"\r\n        if (closeEvent.code !== 1000) {\r\n            message = \"Connection was aborted. Error code: \" + closeEvent.code\r\n        }\r\n\r\n        const error = new Error(message)\r\n        Object.defineProperty(error, \"code\", { value: -32003 })\r\n\r\n        for (const messageId in this.pendingMessages) {\r\n            if (Object.prototype.hasOwnProperty.call(this.pendingMessages, messageId)) {\r\n                const pending = this.pendingMessages[messageId]\r\n                if (pending) {\r\n                    // clear pending message\r\n                    delete this.pendingMessages[messageId]\r\n\r\n                    // reject the promise\r\n                    this.errorFilter(error)\r\n                    pending.reject(error)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private connectPromise?: Promise<string>\r\n\r\n    public connect(credentials?: ICredentials): Promise<string> {\r\n        // you only connect once\r\n        if (this.connectPromise) {\r\n            return this.connectPromise\r\n        }\r\n\r\n        // make sure to have some credentials\r\n        const creds: ICredentials = credentials || this.credentials || new CredentialsBase()\r\n\r\n        return this.connectPromise = new Promise<string>((resolve, reject) => {\r\n            // check if already connected\r\n            if (this.webSocket) {\r\n                resolve(this.sessionId)\r\n                return\r\n            }\r\n\r\n            this.webSocket = new WebSocket(this.url)\r\n\r\n            this.webSocket.onerror = (error: any) => {\r\n                this.connected = false\r\n                delete this.webSocket\r\n                delete this.connectPromise\r\n\r\n                let message = \"Couldn't connect to \" + this.url\r\n                if (error.message) {\r\n                    message = message + \": \" + error.message\r\n                }\r\n\r\n                const e = new Error(message)\r\n                this.errorFilter(e)\r\n                reject(e)\r\n            }\r\n\r\n            this.webSocket.onopen = async () => {\r\n                // this is crucial for the subsequent authenticate call\r\n                this.connected = true\r\n                try {\r\n                    // authenticate\r\n                    this.sessionId = await creds.authenticate(this)\r\n\r\n                    // great, now we're connected\r\n                    this.reconnects = 0\r\n                    resolve(this.sessionId)\r\n                } catch (e) {\r\n                    // report failure\r\n                    this.connected = false\r\n                    this.errorFilter(e)\r\n                    reject(e)\r\n                    delete this.webSocket\r\n                    delete this.connectPromise\r\n                }\r\n            }\r\n\r\n            this.webSocket.onclose = (closeEvent: any) => {\r\n                this.connected = false\r\n                this.rejectPendingMessages(closeEvent)\r\n                delete this.webSocket\r\n                delete this.connectPromise\r\n\r\n                if (closeEvent.code === 1000) {\r\n                    resolve(this.sessionId)\r\n                    return // closed normally, don't reconnect\r\n                }\r\n\r\n                this.reconnects++\r\n                if (this.options.reconnect && (this.options.maxReconnects < this.reconnects || this.options.maxReconnects === 0)) {\r\n                    setTimeout(() => this.connect(), this.options.reconnectInterval)\r\n                }\r\n\r\n                resolve(this.sessionId)\r\n            }\r\n\r\n            this.webSocket.onmessage = (message: any) => {\r\n                // trace incoming message\r\n                this.traceMessage({\r\n                    isOutcoming: false,\r\n                    data: message.data.toString(),\r\n                })\r\n\r\n                // if message is binary data, convert it to string\r\n                let json = typeof(message.data) === \"string\" ? message.data : \"\"\r\n                if (message.data instanceof ArrayBuffer) {\r\n                    json = Buffer.from(message.data).toString()\r\n                }\r\n\r\n                // parse message and get its data\r\n                let parsedMessage: {\r\n                    id?: string,\r\n                    method?: string,\r\n                    params?: object,\r\n                    result?: object,\r\n                    error?: IJsonRpcError,\r\n                }\r\n\r\n                try {\r\n                    parsedMessage = JSON.parse(json)\r\n                } catch(e) {\r\n                    // TODO: decide how to handle parse errors\r\n                    this.errorFilter(e)\r\n                    this.errorFilter(new Error(\"Error parsing JSON: \" + json))\r\n                    return\r\n                }\r\n\r\n                // check if it's a reply\r\n                if (parsedMessage.id) {\r\n                    const pending = this.pendingMessages[parsedMessage.id]\r\n                    if (pending) {\r\n                        // clear pending message\r\n                        delete this.pendingMessages[parsedMessage.id]\r\n\r\n                        // resolve or reject the promise depending on the parsed message data\r\n                        if (parsedMessage.error) {\r\n                            this.errorFilter(parsedMessage.error)\r\n                            pending.reject(parsedMessage.error)\r\n                            return\r\n                        } else {\r\n                            pending.resolve(parsedMessage.result)\r\n                        }\r\n                    }\r\n\r\n                    // TODO: decide how to handle unknown responses from server\r\n                    return\r\n                }\r\n\r\n                // it's a notification, fire an event\r\n                this.subscriptionManager.broadcast(parsedMessage.method!, parsedMessage.params!)\r\n            }\r\n        })\r\n    }\r\n\r\n    public call<T>(message: IReturn<T>): Promise<T>\r\n    public call(message: IReturnVoid): Promise<any>\r\n    public async call<T>(message: IReturn<T> | IReturnVoid): Promise<any> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        return await this.callCore(message)\r\n    }\r\n\r\n    private callCore<T>(message: IReturn<T> | IReturnVoid): Promise<any> {\r\n        const name = this.nameOf(message)\r\n        const messageId = this.generateMessageId()\r\n        const msg = new RequestMessage(name, message, messageId)\r\n        const serialized = JSON.stringify(msg)\r\n\r\n        // prepare pending message\r\n        const pendingMessage = new PendingMessage(messageId)\r\n        this.pendingMessages[messageId] = pendingMessage\r\n\r\n        // return a promise awaiting the results of the call\r\n        return pendingMessage.promise = new Promise((resolve, reject) => {\r\n            // store resolve/reject callbacks for later use\r\n            pendingMessage.resolve = resolve\r\n            pendingMessage.reject = reject\r\n\r\n            // fail early if not connected\r\n            if (this.webSocket === undefined || !this.connected) {\r\n                delete this.pendingMessages[messageId]\r\n                const e = new Error(\"WebSocket not connected\")\r\n                this.errorFilter(e)\r\n                reject(e)\r\n                return\r\n            }\r\n\r\n            // trace outcoming message\r\n            this.traceMessage({\r\n                isOutcoming: true,\r\n                data: serialized\r\n            })\r\n\r\n            // send it\r\n            this.webSocket.send(serialized)\r\n        })\r\n    }\r\n\r\n    // one-way calls\r\n    public async notify<T>(message: IReturn<T> | IReturnVoid): Promise<void> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        const name = this.nameOf(message)\r\n        const msg = new RequestMessage(name, message)\r\n        const serialized = JSON.stringify(msg)\r\n\r\n        // fail if not connected\r\n        if (this.webSocket === undefined || !this.connected) {\r\n            const e = new Error(\"WebSocket not connected\")\r\n            this.errorFilter(e)\r\n            throw e\r\n        }\r\n\r\n        // trace outcoming message\r\n        this.traceMessage({\r\n            isOutcoming: true,\r\n            data: serialized\r\n        })\r\n\r\n        // send it\r\n        this.webSocket.send(serialized)\r\n    }\r\n\r\n    // outgoing message ids\r\n    private lastMessageId = 0\r\n    private generateMessageId() {\r\n        return ++this.lastMessageId + \"\"\r\n    }\r\n\r\n    // stolen from the ServiceStack client\r\n    public nameOf(o: any) {\r\n        if (!o) {\r\n            return \"null\"\r\n        }\r\n\r\n        if (typeof o.getTypeName === \"function\") {\r\n            return o.getTypeName()\r\n        }\r\n\r\n        const ctor = o && o.constructor\r\n        if (ctor === null) {\r\n            const e = new Error(`${o} doesn't have constructor`)\r\n            this.errorFilter(e)\r\n            throw e\r\n        }\r\n\r\n        if (ctor.name) {\r\n            return ctor.name\r\n        }\r\n\r\n        const str = ctor.toString()\r\n        return str.substring(9, str.indexOf(\"(\")) // \"function \".length == 9\r\n    }\r\n\r\n    private subscriptionManager = new ClientSubscriptionManager()\r\n\r\n    // returns unsubscription function\r\n    public async subscribe(event: ISubscription): Promise<() => Promise<void>> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        const cs = new ClientSubscription()\r\n        cs.subscriptionId = this.generateMessageId()\r\n        cs.eventName = event.eventName\r\n        cs.eventHandler = event.eventHandler\r\n        cs.eventFilter = event.eventFilter\r\n\r\n        // notify the server about the new subscription\r\n        const subMessage = cs.createSubscriptionMessage()\r\n        await this.call(subMessage)\r\n\r\n        // return async unsubscription\r\n        const unsubscribe = this.subscriptionManager.add(cs)\r\n        const unsubMessage = cs.createUnsubscriptionMessage()\r\n        return async () => {\r\n            unsubscribe()\r\n            await this.call(unsubMessage)\r\n        }\r\n    }\r\n}\r\n\r\nexport default JsonClient\r\n","export class VersionResponse {\r\n    public ProductName!: string\r\n    public ProductVersion!: string\r\n    public EngineVersion!: string\r\n}\r\n","import { IReturn } from \"../IReturn\"\r\nimport { VersionResponse } from \"./VersionResponse\"\r\n\r\nexport class VersionRequest implements IReturn<VersionResponse> {\r\n    public getTypeName() {\r\n        return \"rpc.version\"\r\n    }\r\n    public createResponse(): VersionResponse {\r\n        return new VersionResponse()\r\n    }\r\n}"],"names":["AuthResponse","AuthRequest","EventFilter","matches","eventFilter","eventArgs","Object","keys","length","key","prototype","hasOwnProperty","call","this","valueMatches","filterValue","propertyValue","undefined","toString","stringMatches","numberMatches","boolMatches","toLowerCase","indexOf","value","split","findIndex","v","trim","SubscriptionMessage","messageName","ClientSubscription","_this","eventHandler","msg","Subscriptions","Enabled","EventName","eventName","SubscriptionId","subscriptionId","createSubscriptionMessage","ClientSubscriptionManager","EventEmitter","subscription","subscriptions","emitter","on","invoke","off","emit","CredentialsBase","credentials","parameters","userNameKey","userName","passwordKey","password","authenticate","client","Parameters","response","SessionId","LogoutMessage","getTypeName","PendingMessage","id","promise","RequestMessage","method","params","JsonClient","url","options","reconnect","reconnectInterval","maxReconnects","_","bind","notify","subscribe","generateMessageId","nameOf","disconnect","_this2","webSocket","connected","close","connectPromise","rejectPendingMessages","closeEvent","message","code","error","Error","messageId","defineProperty","pendingMessages","pending","errorFilter","reject","connect","creds","Promise","resolve","_this3","sessionId","WebSocket","onerror","e","onopen","reconnects","onclose","setTimeout","onmessage","traceMessage","isOutcoming","data","parsedMessage","json","ArrayBuffer","Buffer","from","JSON","parse","result","subscriptionManager","broadcast","_this5","callCore","name","serialized","stringify","pendingMessage","_this6","send","_this8","lastMessageId","o","ctor","constructor","str","substring","event","cs","_this10","subMessage","unsubscribe","add","unsubMessage","createUnsubscriptionMessage","VersionResponse","VersionRequest","createResponse"],"mappings":"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"}