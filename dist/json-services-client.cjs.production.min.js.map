{"version":3,"file":"json-services-client.cjs.production.min.js","sources":["../src/Messages/AuthResponse.ts","../src/Messages/AuthRequest.ts","../src/EventFilter.ts","../src/Messages/SubscriptionMessage.ts","../src/ClientSubscription.ts","../src/ClientSubscriptionManager.ts","../src/CredentialsBase.ts","../.yarn/cache/babel-plugin-transform-async-to-promises-npm-0.8.15-e24f37569f-1.zip/node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Messages/LogoutMessage.ts","../src/PendingMessage.ts","../src/RequestMessage.ts","../src/JsonClient.ts","../src/Messages/VersionResponse.ts","../src/Messages/VersionRequest.ts"],"sourcesContent":["export class AuthResponse {\r\n    public Parameters!: {\r\n        [key: string]: string\r\n    }\r\n\r\n    public SessionId!: string\r\n\r\n    public AuthenticatedIdentity!: {\r\n        Name: string\r\n        AuthenticationType: string\r\n        IsAuthenticated: boolean\r\n    }\r\n}","import { AuthResponse } from \"./AuthResponse\"\r\nimport { IReturn } from \"../IReturn\"\r\n\r\nexport class AuthRequest implements IReturn<AuthResponse> {\r\n    public static userNameKey = \"UserName\"\r\n    public static passwordKey = \"Password\"\r\n    public getTypeName = () => \"rpc.authenticate\"\r\n    public createResponse = () => new AuthResponse()\r\n    public Parameters: {\r\n        [key: string]: string\r\n    } = {}\r\n}\r\n","export interface IEventFilter {\r\n    [key: string]: string | null\r\n}\r\n\r\nexport class EventFilter {\r\n    public static matches(eventFilter?: IEventFilter | null, eventArgs?: { [key: string]: any } | null): boolean {\r\n        // empty filter matches anything\r\n        if (eventFilter === null ||\r\n            eventFilter === undefined ||\r\n            Object.keys(eventFilter).length === 0) {\r\n            return true\r\n        }\r\n\r\n        // empty event arguments doesn't match any filter except for empty filter\r\n        if (eventArgs === null || eventArgs === undefined) {\r\n            return false\r\n        }\r\n\r\n        // match individual properties based on their types\r\n        for (const key in eventFilter) {\r\n            // check eventFilter's own properties\r\n            if (Object.prototype.hasOwnProperty.call(eventFilter, key)) {\r\n                const filterValue = eventFilter[key] || \"\"\r\n                const propertyValue = eventArgs[key]\r\n                if (!this.valueMatches(filterValue, propertyValue)) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    public static valueMatches(filterValue: string, propertyValue: any) {\r\n        // property not found\r\n        if (propertyValue === undefined) {\r\n            return false\r\n        }\r\n\r\n        // empty filter matches anything\r\n        if ((filterValue || \"\") === \"\") {\r\n            return true\r\n        }\r\n\r\n        // match based on the property value type\r\n        if (filterValue === (propertyValue || \"\").toString()) {\r\n            return true\r\n        } else if (typeof propertyValue === \"string\") {\r\n            return this.stringMatches(filterValue, propertyValue)\r\n        } else if (typeof propertyValue === \"number\") {\r\n            return this.numberMatches(filterValue, propertyValue)\r\n        } else if (typeof propertyValue === \"boolean\") {\r\n            return this.boolMatches(filterValue, propertyValue)\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    public static stringMatches(filterValue?: string | null, propertyValue?: string | null) {\r\n        // avoid null and undefined\r\n        filterValue = (filterValue || \"\").toLowerCase()\r\n        propertyValue = (propertyValue || \"\").toLowerCase()\r\n        return propertyValue.indexOf(filterValue) >= 0\r\n    }\r\n\r\n    public static numberMatches(filterValue?: string | null, propertyValue?: number | null) {\r\n        // avoid null and undefined\r\n        filterValue = filterValue || \"\"\r\n        if (filterValue === \"\") {\r\n            return true\r\n        }\r\n\r\n        const value = propertyValue || \"\"\r\n        const parts = filterValue.toLowerCase().split(\",\")\r\n        return parts.findIndex(v => v === value.toString()) >= 0\r\n    }\r\n\r\n    public static boolMatches(filterValue?: string | null, propertyValue?: boolean | null) {\r\n        // avoid null and undefined\r\n        filterValue = filterValue || \"\"\r\n        if (filterValue === \"\") {\r\n            return true\r\n        }\r\n\r\n        const value = (propertyValue || false).toString().toLowerCase().trim()\r\n        return filterValue.toLowerCase().trim() === value\r\n    }\r\n}","import { IReturnVoid } from \"../IReturn\"\r\n\r\ninterface ISubscription {\r\n    SubscriptionId: string\r\n    Enabled: boolean\r\n    EventName: string\r\n    EventFilter?: {\r\n        [key: string]: string\r\n    }\r\n}\r\n\r\nexport class SubscriptionMessage implements IReturnVoid {\r\n    public static messageName = \"rpc.subscription\"\r\n    public getTypeName = () => SubscriptionMessage.messageName\r\n    public Subscriptions!: ISubscription[]\r\n}\r\n","import { EventFilter } from \"./EventFilter\"\r\nimport { SubscriptionMessage } from \"./Messages/SubscriptionMessage\"\r\n\r\nexport class ClientSubscription {\r\n    public subscriptionId!: string\r\n    public eventName!: string\r\n    public eventHandler!: (eventArgs: object) => void\r\n    public eventFilter?: {\r\n        [key: string]: string;\r\n    }\r\n\r\n    public invoke = (eventArgs: object) => {\r\n        // TODO: handle 'this' context?\r\n        // apply eventFilter locally (we might get events matching other local subscriber's event filter)\r\n        if (EventFilter.matches(this.eventFilter, eventArgs)) {\r\n            this.eventHandler(eventArgs)\r\n        }\r\n    }\r\n\r\n    public createSubscriptionMessage = () => {\r\n        const msg = new SubscriptionMessage()\r\n        msg.Subscriptions = [{\r\n            Enabled: true,\r\n            EventName: this.eventName,\r\n            EventFilter: this.eventFilter,\r\n            SubscriptionId: this.subscriptionId,\r\n        }]\r\n        return msg\r\n    }\r\n\r\n    public createUnsubscriptionMessage = () => {\r\n        const msg = this.createSubscriptionMessage()\r\n        delete msg.Subscriptions[0].EventFilter\r\n        msg.Subscriptions[0].Enabled = false\r\n        return msg\r\n    }\r\n}","import { EventEmitter } from \"eventemitter3\"\r\nimport { ClientSubscription } from \"./ClientSubscription\"\r\n\r\nexport class ClientSubscriptionManager {\r\n    private emitter = new EventEmitter()\r\n    private subscriptions: { [subscriptionId: string]: ClientSubscription; } = {}\r\n\r\n    public add = (subscription: ClientSubscription) => {\r\n        this.subscriptions[subscription.subscriptionId] = subscription\r\n        this.emitter.on(subscription.eventName, subscription.invoke, subscription)\r\n\r\n        return () => {\r\n            delete this.subscriptions[subscription.subscriptionId]\r\n            this.emitter.off(subscription.eventName, subscription.invoke, subscription)\r\n        }\r\n    }\r\n\r\n    public broadcast = (eventName: string, eventArgs: object) => {\r\n        this.emitter.emit(eventName, eventArgs)\r\n    }\r\n}","import { AuthRequest } from \"./Messages/AuthRequest\"\r\nimport { ICredentials } from \"./ICredentials\"\r\nimport { IJsonClient } from \"./IJsonClient\"\r\n\r\nexport class CredentialsBase implements ICredentials {\r\n    constructor(credentials?: {\r\n        userName: string,\r\n        password: string,\r\n    } | undefined) {\r\n        // initialize parameters if specified\r\n        if (credentials) {\r\n            this.parameters[AuthRequest.userNameKey] = credentials.userName\r\n            this.parameters[AuthRequest.passwordKey] = credentials.password\r\n        }\r\n    }\r\n\r\n    public async authenticate(client: IJsonClient): Promise<string> {\r\n        const msg = new AuthRequest()\r\n        msg.Parameters = this.parameters\r\n        const response = await client.call(msg)\r\n        return response.SessionId\r\n    }\r\n\r\n    public parameters: {\r\n        [key: string]: string\r\n    } = {}\r\n}","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { IReturnVoid } from \"../IReturn\"\r\n\r\nexport class LogoutMessage implements IReturnVoid {\r\n    public getTypeName() {\r\n        return \"rpc.logout\"\r\n    }\r\n}","﻿export class PendingMessage {\r\n    constructor(public id: string, public promise?: Promise<any>) {\r\n    }\r\n\r\n    public resolve!: (result: any) => void\r\n    public reject!: (error: any) => void\r\n}\r\n\r\nexport interface IPendingMessageQueue {\r\n    [key: string]: PendingMessage | undefined\r\n}","﻿export class RequestMessage {\r\n    constructor(method: string, params: object, id?: string) {\r\n        this.method = method\r\n        this.params = params\r\n        this.id = id\r\n    }\r\n\r\n    public jsonrpc = \"2.0\"\r\n    public method: string\r\n    public params: object\r\n    public id?: string\r\n}","﻿import WebSocket from \"isomorphic-ws\"\r\nimport { ClientSubscription } from \"./ClientSubscription\"\r\nimport { ClientSubscriptionManager } from \"./ClientSubscriptionManager\"\r\nimport { CredentialsBase } from \"./CredentialsBase\"\r\nimport { ICredentials } from \"./ICredentials\"\r\nimport { IJsonClient } from \"./IJsonClient\"\r\nimport { IReturn, IReturnVoid } from \"./IReturn\"\r\nimport { ISubscription } from \"./ISubscription\"\r\nimport { LogoutMessage } from \"./Messages/LogoutMessage\"\r\nimport { IPendingMessageQueue, PendingMessage } from \"./PendingMessage\"\r\nimport { RequestMessage } from \"./RequestMessage\"\r\n\r\nexport interface IJsonRpcError {\r\n    code: number\r\n    message: string\r\n    data: object\r\n}\r\n\r\nexport interface IJsonClientOptions {\r\n    reconnect: boolean\r\n    reconnectInterval: number\r\n    maxReconnects: number\r\n    credentials?: ICredentials\r\n}\r\n\r\nexport class JsonClient implements IJsonClient {\r\n    constructor(public url: string, private options: IJsonClientOptions = {\r\n        reconnect: true,\r\n        reconnectInterval: 5000,\r\n        maxReconnects: 10,\r\n    }) {\r\n        this.credentials = options.credentials\r\n\r\n        // make sure that this argument stays\r\n        this.call = this.call.bind(this)\r\n        this.notify = this.notify.bind(this)\r\n        this.subscribe = this.subscribe.bind(this)\r\n        this.generateMessageId = this.generateMessageId.bind(this)\r\n        this.nameOf = this.nameOf.bind(this)\r\n    }\r\n\r\n    public connected = false\r\n    public sessionId?: string\r\n    public credentials?: ICredentials\r\n    private webSocket?: WebSocket\r\n    private reconnects = 0\r\n    private pendingMessages: IPendingMessageQueue = {}\r\n\r\n    public traceMessage = (_: { isOutcoming: boolean, data: string }) => {\r\n        // do nothing by default\r\n    }\r\n\r\n    public errorFilter = (_: Error | IJsonRpcError) => {\r\n        // do nothing by default\r\n    }\r\n\r\n    public async disconnect() {\r\n        if (this.webSocket && this.connected) {\r\n            await this.notify(new LogoutMessage())\r\n            this.webSocket.close()\r\n            this.connected = false\r\n            delete this.webSocket\r\n            delete this.connectPromise\r\n        }\r\n    }\r\n\r\n    private rejectPendingMessages(closeEvent: {\r\n        wasClean: boolean;\r\n        code: number;\r\n        reason: string;\r\n        target: WebSocket;\r\n    }) {\r\n        let message = \"Connection was closed.\"\r\n        if (closeEvent.code !== 1000) {\r\n            message = \"Connection was aborted. Error code: \" + closeEvent.code\r\n        }\r\n\r\n        const error = new Error(message)\r\n        Object.defineProperty(error, \"code\", { value: -32003 })\r\n\r\n        for (const messageId in this.pendingMessages) {\r\n            if (Object.prototype.hasOwnProperty.call(this.pendingMessages, messageId)) {\r\n                const pending = this.pendingMessages[messageId]\r\n                if (pending) {\r\n                    // clear pending message\r\n                    delete this.pendingMessages[messageId]\r\n\r\n                    // reject the promise\r\n                    this.errorFilter(error)\r\n                    pending.reject(error)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private connectPromise?: Promise<string>\r\n\r\n    public connect(credentials?: ICredentials): Promise<string> {\r\n        // you only connect once\r\n        if (this.connectPromise) {\r\n            return this.connectPromise\r\n        }\r\n\r\n        // make sure to have some credentials\r\n        const creds: ICredentials = credentials || this.credentials || new CredentialsBase()\r\n\r\n        return this.connectPromise = new Promise<string>((resolve, reject) => {\r\n            // check if already connected\r\n            if (this.webSocket) {\r\n                resolve(this.sessionId)\r\n                return\r\n            }\r\n\r\n            this.webSocket = new WebSocket(this.url)\r\n\r\n            this.webSocket.onerror = (error: any) => {\r\n                this.connected = false\r\n                delete this.webSocket\r\n                delete this.connectPromise\r\n\r\n                let message = \"Couldn't connect to \" + this.url\r\n                if (error.message) {\r\n                    message = message + \": \" + error.message\r\n                }\r\n\r\n                const e = new Error(message)\r\n                this.errorFilter(e)\r\n                reject(e)\r\n            }\r\n\r\n            this.webSocket.onopen = async () => {\r\n                // this is crucial for the subsequent authenticate call\r\n                this.connected = true\r\n                try {\r\n                    // authenticate\r\n                    this.sessionId = await creds.authenticate(this)\r\n\r\n                    // great, now we're connected\r\n                    this.reconnects = 0\r\n                    resolve(this.sessionId)\r\n                } catch (e) {\r\n                    // report failure\r\n                    this.connected = false\r\n                    this.errorFilter(e)\r\n                    reject(e)\r\n                    delete this.webSocket\r\n                    delete this.connectPromise\r\n                }\r\n            }\r\n\r\n            this.webSocket.onclose = (closeEvent: any) => {\r\n                this.connected = false\r\n                this.rejectPendingMessages(closeEvent)\r\n                delete this.webSocket\r\n                delete this.connectPromise\r\n\r\n                if (closeEvent.code === 1000) {\r\n                    resolve(this.sessionId)\r\n                    return // closed normally, don't reconnect\r\n                }\r\n\r\n                this.reconnects++\r\n                if (this.options.reconnect && (this.options.maxReconnects < this.reconnects || this.options.maxReconnects === 0)) {\r\n                    setTimeout(() => this.connect(), this.options.reconnectInterval)\r\n                }\r\n\r\n                resolve(this.sessionId)\r\n            }\r\n\r\n            this.webSocket.onmessage = (message: any) => {\r\n                // trace incoming message\r\n                this.traceMessage({\r\n                    isOutcoming: false,\r\n                    data: message.data.toString(),\r\n                })\r\n\r\n                // if message is binary data, convert it to string\r\n                let json = typeof(message.data) === \"string\" ? message.data : \"\"\r\n                if (message.data instanceof ArrayBuffer) {\r\n                    json = Buffer.from(message.data).toString()\r\n                }\r\n\r\n                // parse message and get its data\r\n                let parsedMessage: {\r\n                    id?: string,\r\n                    method?: string,\r\n                    params?: object,\r\n                    result?: object,\r\n                    error?: IJsonRpcError,\r\n                }\r\n\r\n                try {\r\n                    parsedMessage = JSON.parse(json)\r\n                } catch(e) {\r\n                    // TODO: decide how to handle parse errors\r\n                    this.errorFilter(e)\r\n                    this.errorFilter(new Error(\"Error parsing JSON: \" + json))\r\n                    return\r\n                }\r\n\r\n                // check if it's a reply\r\n                if (parsedMessage.id) {\r\n                    const pending = this.pendingMessages[parsedMessage.id]\r\n                    if (pending) {\r\n                        // clear pending message\r\n                        delete this.pendingMessages[parsedMessage.id]\r\n\r\n                        // resolve or reject the promise depending on the parsed message data\r\n                        if (parsedMessage.error) {\r\n                            this.errorFilter(parsedMessage.error)\r\n                            pending.reject(parsedMessage.error)\r\n                            return\r\n                        } else {\r\n                            pending.resolve(parsedMessage.result)\r\n                        }\r\n                    }\r\n\r\n                    // TODO: decide how to handle unknown responses from server\r\n                    return\r\n                }\r\n\r\n                // it's a notification, fire an event\r\n                this.subscriptionManager.broadcast(parsedMessage.method!, parsedMessage.params!)\r\n            }\r\n        })\r\n    }\r\n\r\n    public call<T>(message: IReturn<T>): Promise<T>\r\n    public call(message: IReturnVoid): Promise<any>\r\n    public async call<T>(message: IReturn<T> | IReturnVoid): Promise<any> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        return await this.callCore(message)\r\n    }\r\n\r\n    private callCore<T>(message: IReturn<T> | IReturnVoid): Promise<any> {\r\n        const name = this.nameOf(message)\r\n        const messageId = this.generateMessageId()\r\n        const msg = new RequestMessage(name, message, messageId)\r\n        const serialized = JSON.stringify(msg)\r\n\r\n        // prepare pending message\r\n        const pendingMessage = new PendingMessage(messageId)\r\n        this.pendingMessages[messageId] = pendingMessage\r\n\r\n        // return a promise awaiting the results of the call\r\n        return pendingMessage.promise = new Promise((resolve, reject) => {\r\n            // store resolve/reject callbacks for later use\r\n            pendingMessage.resolve = resolve\r\n            pendingMessage.reject = reject\r\n\r\n            // fail early if not connected\r\n            if (this.webSocket === undefined || !this.connected) {\r\n                delete this.pendingMessages[messageId]\r\n                const e = new Error(\"WebSocket not connected\")\r\n                this.errorFilter(e)\r\n                reject(e)\r\n                return\r\n            }\r\n\r\n            // trace outcoming message\r\n            this.traceMessage({\r\n                isOutcoming: true,\r\n                data: serialized\r\n            })\r\n\r\n            // send it\r\n            this.webSocket.send(serialized)\r\n        })\r\n    }\r\n\r\n    // one-way calls\r\n    public async notify<T>(message: IReturn<T> | IReturnVoid): Promise<void> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        const name = this.nameOf(message)\r\n        const msg = new RequestMessage(name, message)\r\n        const serialized = JSON.stringify(msg)\r\n\r\n        // fail if not connected\r\n        if (this.webSocket === undefined || !this.connected) {\r\n            const e = new Error(\"WebSocket not connected\")\r\n            this.errorFilter(e)\r\n            throw e\r\n        }\r\n\r\n        // trace outcoming message\r\n        this.traceMessage({\r\n            isOutcoming: true,\r\n            data: serialized\r\n        })\r\n\r\n        // send it\r\n        this.webSocket.send(serialized)\r\n    }\r\n\r\n    // outgoing message ids\r\n    private lastMessageId = 0\r\n    private generateMessageId() {\r\n        return ++this.lastMessageId + \"\"\r\n    }\r\n\r\n    // stolen from the ServiceStack client\r\n    public nameOf(o: any) {\r\n        if (!o) {\r\n            return \"null\"\r\n        }\r\n\r\n        if (typeof o.getTypeName === \"function\") {\r\n            return o.getTypeName()\r\n        }\r\n\r\n        const ctor = o && o.constructor\r\n        if (ctor === null) {\r\n            const e = new Error(`${o} doesn't have constructor`)\r\n            this.errorFilter(e)\r\n            throw e\r\n        }\r\n\r\n        if (ctor.name) {\r\n            return ctor.name\r\n        }\r\n\r\n        const str = ctor.toString()\r\n        return str.substring(9, str.indexOf(\"(\")) // \"function \".length == 9\r\n    }\r\n\r\n    private subscriptionManager = new ClientSubscriptionManager()\r\n\r\n    // returns unsubscription function\r\n    public async subscribe(event: ISubscription): Promise<() => Promise<void>> {\r\n        if (!this.connected) {\r\n            await this.connect()\r\n        }\r\n\r\n        const cs = new ClientSubscription()\r\n        cs.subscriptionId = this.generateMessageId()\r\n        cs.eventName = event.eventName\r\n        cs.eventHandler = event.eventHandler\r\n        cs.eventFilter = event.eventFilter\r\n\r\n        // notify the server about the new subscription\r\n        const subMessage = cs.createSubscriptionMessage()\r\n        await this.call(subMessage)\r\n\r\n        // return async unsubscription\r\n        const unsubscribe = this.subscriptionManager.add(cs)\r\n        const unsubMessage = cs.createUnsubscriptionMessage()\r\n        return async () => {\r\n            unsubscribe()\r\n            await this.call(unsubMessage)\r\n        }\r\n    }\r\n}\r\n\r\nexport default JsonClient\r\n","export class VersionResponse {\r\n    public ProductName!: string\r\n    public ProductVersion!: string\r\n    public EngineVersion!: string\r\n}\r\n","import { IReturn } from \"../IReturn\"\r\nimport { VersionResponse } from \"./VersionResponse\"\r\n\r\nexport class VersionRequest implements IReturn<VersionResponse> {\r\n    public getTypeName() {\r\n        return \"rpc.version\"\r\n    }\r\n    public createResponse(): VersionResponse {\r\n        return new VersionResponse()\r\n    }\r\n}"],"names":["AuthResponse","AuthRequest","EventFilter","matches","eventFilter","eventArgs","Object","keys","length","key","prototype","hasOwnProperty","call","this","valueMatches","filterValue","propertyValue","undefined","toString","stringMatches","numberMatches","boolMatches","toLowerCase","indexOf","value","split","findIndex","v","trim","SubscriptionMessage","messageName","ClientSubscription","_this","eventHandler","msg","Subscriptions","Enabled","EventName","eventName","SubscriptionId","subscriptionId","createSubscriptionMessage","ClientSubscriptionManager","EventEmitter","subscription","subscriptions","emitter","on","invoke","off","emit","CredentialsBase","credentials","parameters","userNameKey","userName","passwordKey","password","authenticate","client","Parameters","response","SessionId","Symbol","iterator","asyncIterator","LogoutMessage","getTypeName","PendingMessage","id","promise","RequestMessage","method","params","JsonClient","url","options","reconnect","reconnectInterval","maxReconnects","_","bind","notify","subscribe","generateMessageId","nameOf","disconnect","_this2","webSocket","connected","close","connectPromise","rejectPendingMessages","closeEvent","message","code","error","Error","messageId","defineProperty","pendingMessages","pending","errorFilter","reject","connect","creds","Promise","resolve","_this3","sessionId","WebSocket","onerror","e","onopen","body","recover","result","reconnects","then","onclose","setTimeout","onmessage","traceMessage","isOutcoming","data","parsedMessage","json","ArrayBuffer","Buffer","from","JSON","parse","subscriptionManager","broadcast","_this5","callCore","name","serialized","stringify","pendingMessage","_this6","send","_this8","lastMessageId","o","ctor","constructor","str","substring","event","cs","_this10","subMessage","unsubscribe","add","unsubMessage","createUnsubscriptionMessage","VersionResponse","VersionRequest","createResponse"],"mappings":"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"}